#include <Arduino.h>

#define NUM_CELLS_PER_UNIT 2
#define NUM_UNITS          1

// Pin definierung
const int PIN_ZELLE1 = A1;
const int PIN_GESAMT = A2;
const int PIN_MAIN_SWITCH = 4; // D4 Steuert den Last-MOSFET
const int PIN_STATUS_LED = 13; // Onboard LED
const int PIN_MOSFET_ZELLE1 = 5;
const int PIN_MOSFET_ZELLE2 = 6;
const int Stromsensor_pin = A3;

// Konstanten fuer die Berechnungen und das Balancing 
const float V_REF = 5.0;         // Exakte Spannung am 5V Pin (bitte nachmessen!)
const float DIVIDER_FAKTOR = 2.0; // Da 10k/10k Teiler die Spannung halbiert
const float MIN_VOLT_ZELLE = 3.0; // Abschaltung bei 3.0V pro Zelle
const float MAX_VOLT_ZELLE = 4.2; // 100% bei 4.2V pro Zelle
const float diffStart = 0.05; // Wert der Differenz bei der das Balancing gestartet werden soll
const float diffStop = 0.01;  // Wert der Differenz bei der das Balancing gestoppy werden soll bzw. die Tolelranz die die beiden Zellen max. ahebn duerfen

enum SystemStatus{
  STATUS_IDLE,      // Alles okay, keine Last
  STATUS_DISCHARGE, // Akku wird entladen
  STATUS_CHARGE,    // Akku wird geladen
  STATUS_CRITICAL,  // Not-Aus wegen Unterspannung
  STATUS_FULL       // Akku ist voll, Laden stoppen
}

// Variable fuer das System
SystemStatus currently_status;

struct CellData {
// Messwerte
  int voltage_mV;         // Aktuelle Gesamtzellspannung in Millivolt
  int voltage_Cell1;      // Zellspannung der ersten Zelle
  int voltage_Cell2;      // Zellspannung der zweiten Zelle
  int temperature_C;      // Aktuelle Zelltemperatur in Grad Celsius
  // Status & Steuerung
  byte internal_ID;       // Die interne Kanal-ID im Monitor-IC
  bool is_balancing_1;      // TRUE, wenn der Balancierwiderstand dieser Zelle aktiv ist
  bool is_balancing_2;      // TRUE, wenn der Balancierwiderstand dieser Zelle aktiv ist
  SystemStatus status;
};



// Array in dehnen alle Units gespecihert sind
CellData Units[NUM_UNITS];


void read_Data_for_all_units() {
  for (int i = 0; i < NUM_UNITS; i++) {
    // 1. MESSUNG (Durchschnitt aus 20 Werten für Stabilität)
    float rawA1 = 0;
    float rawA2 = 0;
    for(int i = 0; i < 20; i++) {
      rawA1 += analogRead(PIN_ZELLE1);
      rawA2 += analogRead(PIN_GESAMT);
      delay(2);
    }
    rawA1 /= 20.0;
    rawA2 /= 20.0;

    // 2. UMRECHNUNG IN VOLT
    // Spannung von Zelle 1 (direkt oder via Schutzwiderstand)
    float vZelle1 = (rawA1 * V_REF) / 1024.0;
    
    // Gesamtspannung (Wert am Pin * 2, wegen Teiler)
    float vGesamt = ((rawA2 * V_REF) / 1024.0) * DIVIDER_FAKTOR;
    
    // Zelle 2 berechnen (Differenz)
    float vZelle2 = vGesamt - vZelle1;

    Units[i].voltage_mV = vGesamt;
    Units[i].voltage_Cell1 = vZelle1;
    Units[i].voltage_Cell2 = vZelle2;

    Units[i].temperature_C = 25;
    Units[i].internal_ID = i;
    Units[i].is_balancing = false;

  
  }
}

void update_System_Behavior() {

  // Messunf der Stromrichtung
  float rawA3 = analogRead(PIN_STROM);
  int strom_A = (rawA3 - 512.0) * (5.0 / 1024.0) / 0.185;

  for (int i = 0; i < NUM_UNITS; i++) {
    

    // ueberpruefen ob die Zellen Laden, Entladen oder gar nichts von beiden
    else if (strom_A > 0.05) { // Kleiner Schwellenwert gegen Rauschen
      Units[i].status = STATUS_CHARGE;
    } 
    else if (strom_A < -0.05) {
      Units[i].status = STATUS_DISCHARGE;
    } 
    else {
      Units[i].status = STATUS_IDLE;
    }

    // uberpeufiung auf ueber ubd unterladung
    if (Units[i].voltage_Cell1 < MIN_VOLT_ZELLE || Units[i].voltage_Cell2 < MIN_VOLT_ZELLE) {
        Units[i].status = STATUS_CRITICAL;
    }
      
    if (Units[i].status == STATUS_CHARGE) {
      if (Units[i].voltage_Cell1 >= MAX_VOLT_ZELLE || Units[i].voltage_Cell2 >= MAX_VOLT_ZELLE) {
        // Wir setzen den Status auf IDLE, damit der switch-case 
        // in der Hardware-Phase das Laden unterbricht.
        Units[i].status = STATUS_IDLE; 
      }
    }


    // ueberpruefen ob balancing notwendig ist 
    // differenz beider Akkuzellen
    float diff = Units[i].voltage_Cell1 - Units[i].voltage_Cell2;
    
    // Frage 1: Ist Zelle 1 viel voller als Zelle 2?
    if (diff > diffStart) { 
      Units[i].is_balancing_Z1 = true;  // Merken: Z1 entladen
      Units[i].is_balancing_Z2 = false; // Z2 muss nichts tun
    } 
    // Frage 2: Ist Zelle 2 viel voller als Zelle 1?
    else if (diff < -diffStart) { 
      Units[i].is_balancing_Z1 = false; 
      Units[i].is_balancing_Z2 = true;  // Merken: Z2 entladen
    } 
    // Frage 3: Sind sie nah genug beieinander?
    else if (abs(diff) < diffStop) { 
      Units[i].is_balancing_Z1 = false;
      Units[i].is_balancing_Z2 = false;
    }
  }
}

void execute_Hardware_Controls() {
  for ( int i = 0; i < NUM_UNITS: i++) {

    // hier wird die Status variable ueberprueft
    switch (Units[i].status) {
      
      case STATUS_CRITICAL:
        // Bei Gefahr (Unterspannung/Hitze) wird sofort getrennt
        digitalWrite(PIN_MAIN_SWITCH, LOW);
        break;

      case STATUS_CHARGE:
      case STATUS_DISCHARGE:
      case STATUS_IDLE:
        // In allen normalen Betriebszuständen darf Strom fließen
        digitalWrite(PIN_MAIN_SWITCH, HIGH);
        break;

      default:
        // Sicherheits-Fallback: Im Zweifel aus
        digitalWrite(PIN_MAIN_SWITCH, LOW);
        break;
    }

    // hier wird die Balacing Variable geprueft
    if (Units[i].is_balancing_Z1) {
      digitalWrite(PIN_MOSFET_ZELLE1, HIGH);
    } else {
      digitalWrite(PIN_MOSFET_ZELLE1, LOW);
    }

    // Balancing für Zelle 2
    if (Units[i].is_balancing_Z2) {
      digitalWrite(PIN_MOSFET_ZELLE2, HIGH);
    } else {
      digitalWrite(PIN_MOSFET_ZELLE2, LOW);
    }


  }
}

void print_Data() {
  for (int i = 0; i < NUM_UNITS; i++) {
    Serial.print("Unit ["); Serial.print(Units[i].internal_ID); Serial.print("] ");
    Serial.print("Z1: "); Serial.print(Units[i].voltage_Cell1); Serial.print("V | ");
    Serial.print("Z2: "); Serial.print(Units[i].voltage_Cell2); Serial.print("V | ");
    Serial.print("Gesamt: "); Serial.print(Units[i].voltage_mV); Serial.println("V");
  }
}

void setup() {
  // wichtig fuer das debugging
  Serial.begin(115200);

  while(!Serial); // warten bis der Monitor offen ist
  
  Serial.print("Initialisierung des BMS ...\n");

  pinMode(PIN_MAIN_SWITCH, OUTPUT);
  pinMode(PIN_STATUS_LED, OUTPUT);


}

// Die Hauptschleife läuft unendlich.
void loop() {
  // 1. Daten einlesen
  read_Data_for_all_units();

  // 2. Daten ausgeben
  print_Data();

  // entschieden was getan wird
  update_System_Behavior();

  // ausfuerung



  // 3. Status-LED blinken lassen (ohne delay, damit Messung schnell bleibt)
  digitalWrite(PIN_STATUS_LED, !digitalRead(PIN_STATUS_LED));

  // 4. Kurze Pause bis zur nächsten Messung
  delay(1000);
}